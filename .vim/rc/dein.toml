[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'sainnhe/sonokai'
hook_add = '''
let g:sonokai_style = 'default'
let g:sonokai_disable_italic_comment = 1
let g:sonokai_diagnostic_text_highlight = 1
let g:sonokai_diagnostic_virtual_text = 'colored'
let g:sonokai_better_performance = 1

au MyAutoCmd VimEnter * nested colorscheme sonokai
'''

[[plugins]]
repo = 'tpope/vim-fugitive'

[[plugins]]
repo = 'tpope/vim-rhubarb'

[[plugins]]
repo = 'vim-scripts/sudo.vim'

[[plugins]]
repo = 'tpope/vim-surround'

[[plugins]]
repo = 'Shougo/neomru.vim'

[[plugins]]
repo = 'numToStr/Comment.nvim'
hook_add = '''
lua << EOF
require('Comment').setup()
EOF
'''

[[plugins]]
repo = 'editorconfig/editorconfig-vim'

[[plugins]]
repo = 'dense-analysis/ale'
hook_add = '''
nmap <silent> <leader>aj :ALENext<cr>
nmap <silent> <leader>ak :ALEPrevious<cr>

let g:ale_disable_lsp = 1

let g:ale_sign_error = "\uf05e"
let g:ale_sign_warning = "\uf071"
let g:ale_sign_column_always = 1

let g:ale_set_loclist = 0
let g:ale_set_quickfix = 0
let g:ale_open_list = 0
let g:ale_keep_list_window_open = 0

let g:ale_lint_on_enter = 1
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 'never'
let g:ale_linters = {
\   'go': ['golint', 'govet', 'golangci-lint'],
\   'css': ['stylelint'],
\   'scss': ['stylelint'],
\   'json': ['jq'],
\   'javascript': ['eslint'],
\   'typescript': ['eslint'],
\   'vue': ['eslint', 'stylelint']
\ }

let g:ale_fix_on_save = 1
let g:ale_fixers = {
\   'dart': ['dart-format'],
\   'go': ['goimports'],
\   'css': ['stylelint'],
\   'scss': ['stylelint'],
\   'json': ['jq'],
\   'javascript': ['eslint'],
\   'typescript': ['eslint'],
\   'vue': ['eslint', 'stylelint']
\}

let g:ale_dart_format_options = '--line-length 140'
let g:ale_go_golangci_lint_options = ''
'''

[[plugins]]
repo = 'tpope/vim-repeat'

[[plugins]]
repo = 'andymass/vim-matchup'
hook_add = '''
let g:loaded_matchparen = 1
'''

[[plugins]]
repo = 'itchyny/vim-cursorword'

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
hook_add = '''
map <S-r> <Plug>(operator-replace)
'''

[[plugins]]
repo = 'goolord/alpha-nvim'
depends = 'nvim-web-devicons'
hook_add = '''
lua require'alpha'.setup(require'alpha.themes.startify'.config)
'''

[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
depends = ['plenary.nvim']
hook_add = '''
nnoremap ,p  <cmd>Telescope find_files find_command=rg,--no-ignore-dot,--hidden,-g,!.git/,--files<cr>
nnoremap ,ff <cmd>Telescope find_files find_command=rg,--no-ignore-dot,--hidden,-g,!.git/,--files<cr>
nnoremap ,fm <cmd>Telescope frecency<cr>
nnoremap ,fo <cmd>Telescope oldfiles<cr>
nnoremap ,fg <cmd>Telescope live_grep<cr>
nnoremap ,fG <cmd>Telescope grep_string<cr>
nnoremap ,fb <cmd>Telescope buffers<cr>
nnoremap ,fh <cmd>Telescope help_tags<cr>

nnoremap ,<C-g><C-s> <cmd>Telescope git_status<cr>

lua <<EOL
local actions = require("telescope.actions")
require("telescope").setup{
  defaults = {
    vimgrep_arguments = {
      "rg",
      "--no-ignore-dot",
      "--hidden",
      "-g=!.git/",
      "--color=never",
      "--no-heading",
      "--with-filename",
      "--line-number",
      "--column",
      "--smart-case"
    },
    mappings = {
      i = {
        ["<esc>"] = actions.close,
      },
      n = {
        ["<C-c>"] = actions.close,
        ["q"] = actions.close,
      },
    },
  },
  extensions = {
    frecency = {
      show_scores = true,
      show_unindexed = true,
      ignore_patterns = {"*.git/*", "*/tmp/*"},
      disable_devicons = false,
      default_workspace = 'CWD',
    },
  },
}
EOL
'''

[[plugins]]
repo = 'tami5/sqlite.lua'

[[plugins]]
repo = 'nvim-telescope/telescope-frecency.nvim'
depends = ['telescope.nvim', 'sqlite.lua', 'nvim-web-devicons']
hook_add = '''
lua <<EOL
require('telescope').load_extension('frecency')
EOL
'''

[[plugins]]
repo = 'nvim-lualine/lualine.nvim'
depends = 'nvim-web-devicons'
hook_add = '''
lua << EOF
require('lualine').setup {
  options = {
    icons_enabled = true,
    theme = 'auto',
    component_separators = { left = '', right = ''},
    section_separators = { left = '', right = ''},
    disabled_filetypes = {},
    always_divide_middle = true,
    globalstatus = false,
  },
  sections = {
    lualine_a = {'mode'},
    lualine_b = {
      'branch',
      'diff',
      {
        'diagnostics',
        sources = { 'nvim_diagnostic', 'ale' },
      },
    },
    lualine_c = {'filename'},
    lualine_x = {'encoding', 'fileformat', 'filetype'},
    lualine_y = {'progress'},
    lualine_z = {'location'}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {'filename'},
    lualine_x = {'location'},
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  extensions = {}
}
EOF
'''

[[plugins]]
repo = 'folke/which-key.nvim'
hook_add = '''
lua << EOF
require("which-key").setup {}
EOF
'''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
hook_add = '''
lua << EOF
require('gitsigns').setup{
  signcolumn = true,
  numhl      = true,
  linehl     = false,
  word_diff  = false,
  on_attach = function(bufnr)
    local function map(mode, lhs, rhs, opts)
        opts = vim.tbl_extend('force', {noremap = true, silent = true}, opts or {})
        vim.api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, opts)
    end

    -- Navigation
    map('n', ']c', "&diff ? ']c' : '<cmd>Gitsigns next_hunk<CR>'", {expr=true})
    map('n', '[c', "&diff ? '[c' : '<cmd>Gitsigns prev_hunk<CR>'", {expr=true})

    -- Actions
    map('n', '<leader>ga', ':Gitsigns stage_hunk<CR>')
    map('v', '<leader>ga', ':Gitsigns stage_hunk<CR>')
    map('n', '<leader>gu', '<cmd>Gitsigns undo_stage_hunk<CR>')
    map('n', '<leader>gd', '<cmd>Gitsigns diffthis<CR>')
    map('n', '<leader>gtd', '<cmd>Gitsigns toggle_deleted<CR>')
  end
}
EOF
'''

[[plugins]]
repo = 'norcalli/nvim-colorizer.lua'
hook_add = '''
lua require('colorizer').setup()
'''

[[plugins]]
repo = 'kevinhwang91/nvim-hlslens'
hook_add = '''
lua << EOF
local kopts = {noremap = true, silent = true}

vim.api.nvim_set_keymap('n', 'n',
    [[<Cmd>execute('normal! ' . v:count1 . 'n')<CR><Cmd>lua require('hlslens').start()<CR>]],
    kopts)
vim.api.nvim_set_keymap('n', 'N',
    [[<Cmd>execute('normal! ' . v:count1 . 'N')<CR><Cmd>lua require('hlslens').start()<CR>]],
    kopts)
vim.api.nvim_set_keymap('n', '*', [[*<Cmd>lua require('hlslens').start()<CR>]], kopts)
vim.api.nvim_set_keymap('n', '#', [[#<Cmd>lua require('hlslens').start()<CR>]], kopts)
vim.api.nvim_set_keymap('n', 'g*', [[g*<Cmd>lua require('hlslens').start()<CR>]], kopts)
vim.api.nvim_set_keymap('n', 'g#', [[g#<Cmd>lua require('hlslens').start()<CR>]], kopts)
EOF
'''

[[plugins]]
repo = 'petertriho/nvim-scrollbar'
depends = 'nvim-hlslens'
hook_add = '''
lua << EOF
require("scrollbar.handlers.search").setup()
require("scrollbar").setup({
	show = true,
	set_highlights = true,
	handle = {
		color = "#777777",
	},
	marks = {
		Search = { color = "#ff9e64" },
		Error = { color = "#db4b4b" },
		Warn = { color = "#e0af68" },
		Info = { color = "#0db9d7" },
		Hint = { color = "#1abc9c" },
		Misc = { color = "#9d7cd8" },
	},
	handlers = {
		diagnostic = true,
		search = true,
	},
})
EOF
'''

[[plugins]]
repo = 'wakatime/vim-wakatime'

[[plugins]]
repo = 'rafamadriz/friendly-snippets'

[[plugins]]
repo = 'L3MON4D3/LuaSnip'
depends = 'friendly-snippets'
hook_add = '''
lua require("luasnip.loaders.from_vscode").lazy_load()
'''

[[plugins]]
repo = 'onsails/lspkind.nvim'

[[plugins]]
repo = 'hrsh7th/nvim-cmp'
depends = ['LuaSnip', 'lspkind.nvim']
hook_add = '''
lua <<EOF
  local has_words_before = function()
    local line, col = unpack(vim.api.nvim_win_get_cursor(0))
    return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match("%s") == nil
  end

  local luasnip = require('luasnip')
  local cmp = require('cmp')
  cmp.setup({
    snippet = {
      expand = function(args)
        luasnip.lsp_expand(args.body)
      end,
    },
    formatting = {
      format = require('lspkind').cmp_format({
        mode = 'symbol',
        maxwidth = 50,
        with_text = true,
        menu = {
          buffer = '[Buffer]',
          cmp_tabnine = '[TabNine]',
          luasnip = '[LuaSnip]',
          nvim_lsp = '[LSP]',
          path = '[Path]',
          look = '[Look]',
        },
      }),
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-b>'] = cmp.mapping.scroll_docs(-4),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.abort(),
      ['<CR>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
      ["<Tab>"] = cmp.mapping(function(fallback)
          if cmp.visible() then
              cmp.select_next_item()
          elseif luasnip.expand_or_jumpable() then
              luasnip.expand_or_jump()
          elseif has_words_before() then
              cmp.complete()
          else
              fallback()
          end
      end, { "i", "s" }),
      ["<S-Tab>"] = cmp.mapping(function(fallback)
          if cmp.visible() then
              cmp.select_prev_item()
          elseif luasnip.jumpable(-1) then
              luasnip.jump(-1)
          else
              fallback()
          end
      end, { "i", "s" }),
      }),
    sources = cmp.config.sources({
      { name = 'nvim_lsp' },
      { name = 'cmp_tabnine' },
      { name = 'luasnip' },
      { name = 'path' },
      {
        name = 'look',
        keyword_length = 2,
        option = {
            convert_case = true,
            loud = true
        }
      }
    }, {
      { name = 'buffer' },
    })
  })

  cmp.setup.cmdline('/', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = 'buffer' }
    }
  })

  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })
EOF
'''

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp'
depends = 'nvim-cmp'

[[plugins]]
repo = 'hrsh7th/cmp-buffer'
depends = 'nvim-cmp'

[[plugins]]
repo = 'hrsh7th/cmp-path'
depends = 'nvim-cmp'

[[plugins]]
repo = 'hrsh7th/cmp-cmdline'
depends = 'nvim-cmp'

[[plugins]]
repo = 'saadparwaiz1/cmp_luasnip'
depends = 'nvim-cmp'

[[plugins]]
repo = 'tzachar/cmp-tabnine'
depends = 'nvim-cmp'
build = './install.sh'

[[plugins]]
repo = 'octaltree/cmp-look'
depends = 'nvim-cmp'

[[plugins]]
repo = 'williamboman/nvim-lsp-installer'
hook_add = '''
lua << EOF
require("nvim-lsp-installer").setup({
    ensure_installed = {
        "dartls",
        "dockerls",
        "gopls",
        "golangci_lint_ls",
        "graphql",
        "html",
        "jsonls",
        "tsserver",
        "taplo",
        "terraformls",
        "tflint",
        "volar",
        "cssls",
        "yamlls",
        "bashls",
    },
    automatic_installation = true,
    ui = {
        icons = {
            server_installed = "✓",
            server_pending = "➜",
            server_uninstalled = "✗"
        }
    }
})
EOF
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
depends = ['nvim-lsp-installer', 'cmp-nvim-lsp']
hook_add = '''
lua << EOF
local opts = { noremap=true, silent=true }

local on_attach = function(client, bufnr)
  vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gy', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)

  vim.api.nvim_buf_set_keymap(bufnr, 'n', ',wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', ',wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', ',wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)

  vim.api.nvim_buf_set_keymap(bufnr, 'n', ',f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
end

local capabilities = require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities())
local servers = require("nvim-lsp-installer").get_installed_servers()
for _, lsp in ipairs(servers) do
  require('lspconfig')[lsp.name].setup {
    on_attach = on_attach,
    capabilities = capabilities,
  }
end
EOF
'''

[[plugins]]
repo = 'ray-x/lsp_signature.nvim'
hook_add = '''
lua << EOF
require('lsp_signature').setup()
EOF
'''

[[plugins]]
repo = 'folke/lsp-colors.nvim'

[[plugins]]
repo = 'tami5/lspsaga.nvim'
depends = 'lsp-colors.nvim'
hook_add = '''
nnoremap <silent>,e <cmd>Lspsaga show_line_diagnostics<cr>
nnoremap <silent> [e <cmd>Lspsaga diagnostic_jump_next<CR>
nnoremap <silent> ]e <cmd>Lspsaga diagnostic_jump_prev<CR>

nnoremap <silent>rn <cmd>Lspsaga rename<CR>

nnoremap <silent> gh <cmd>lua require('lspsaga.provider').lsp_finder()<CR>
nnoremap <silent> gd <cmd>lua require('lspsaga.provider').preview_definition()<CR>

nnoremap <silent>,ca <cmd>Lspsaga code_action<CR>
vnoremap <silent>,ca :<C-u>Lspsaga range_code_action<CR>

nnoremap <silent> K <cmd>Lspsaga hover_doc<cr>
nnoremap <silent> ? <cmd>Lspsaga signature_help<cr>

nnoremap <silent> <C-u> <cmd>lua require('lspsaga.action').smart_scroll_with_saga(-1)<CR>
nnoremap <silent> <C-d> <cmd>lua require('lspsaga.action').smart_scroll_with_saga(1)<CR>

lua << EOF
local lspsaga = require 'lspsaga'
lspsaga.setup { -- defaults ...
  debug = false,
  use_saga_diagnostic_sign = true,
  -- diagnostic sign
  error_sign = "",
  warn_sign = "",
  hint_sign = "",
  infor_sign = "",
  diagnostic_header_icon = "   ",
  -- code action title icon
  code_action_icon = " ",
  code_action_prompt = {
    enable = true,
    sign = true,
    sign_priority = 40,
    virtual_text = true,
  },
  finder_definition_icon = "  ",
  finder_reference_icon = "  ",
  max_preview_lines = 10,
  finder_action_keys = {
    open = "<CR>",
    vsplit = "s",
    split = "i",
    quit = "<ESC>",
    scroll_down = "<C-d>",
    scroll_up = "<C-u>",
  },
  code_action_keys = {
    quit = "<ESC>",
    exec = "<CR>",
  },
  rename_action_keys = {
    quit = "<ESC>",
    exec = "<CR>",
  },
  definition_preview_icon = "  ",
  border_style = "single",
  rename_prompt_prefix = "➤",
  rename_output_qflist = {
    enable = false,
    auto_open_qflist = false,
  },
  server_filetype_map = {},
  diagnostic_prefix_format = "%d. ",
  diagnostic_message_format = "%m %c",
  highlight_prefix = false,
}
EOF
'''

[[plugins]]
repo = 'j-hui/fidget.nvim'
hook_add = '''
lua << EOF
require('fidget').setup{}
EOF
'''

[[plugins]]
repo = 'noib3/nvim-cokeline'
depends = 'nvim-web-devicons'
hook_add = '''
lua << EOF
local map = vim.api.nvim_set_keymap
map('n', '[b', '<Plug>(cokeline-focus-prev)',  { silent = true })
map('n', ']b', '<Plug>(cokeline-focus-next)',  { silent = true })
for i = 1,9 do
  map('n', ('b%s'):format(i), ('<Plug>(cokeline-focus-%s)'):format(i),  { silent = true })
end

local get_hex = require('cokeline/utils').get_hex
local mappings = require('cokeline/mappings')

local comments_fg = get_hex('Comment', 'fg')
local errors_fg = get_hex('DiagnosticError', 'fg')
local warnings_fg = get_hex('DiagnosticWarn', 'fg')

local components = {
  space = {
    text = ' ',
    truncation = { priority = 1 }
  },

  separator = {
    text = function(buffer)
      return (buffer.is_focused and ' ')
        or (buffer.filetype == 'neo-tree' and '  ')
        or (buffer.index ~= 1 and ' ▎')
        or '  '
    end,
    bg = get_hex('Normal', 'bg'),
    truncation = { priority = 1 }
  },

  number = {
    text = function(buffer)
      return buffer.index
    end,
    fg = comments_fg,
    truncation = { priority = 1 }
  },

  devicon = {
    text = function(buffer)
      return buffer.devicon.icon
    end,
    fg = function(buffer)
      return buffer.devicon.color
    end,
    truncation = { priority = 2 }
  },

  unique_prefix = {
    text = function(buffer)
      return buffer.unique_prefix
    end,
    fg = comments_fg,
    style = 'italic',
    truncation = {
      priority = 3,
      direction = 'left',
    },
  },

  filename = {
    text = function(buffer)
      return buffer.filename
    end,
    fg = function(buffer)
      return buffer.is_focused and '#78dce8' or nil
    end,
    style = function(buffer)
      return buffer.is_focused and 'bold,underline' or nil
    end,
    truncation = {
      priority = 2,
      direction = 'left',
    },
  },

  diagnostics = {
    text = function(buffer)
      return
        (buffer.diagnostics.errors ~= 0 and '  ' .. buffer.diagnostics.errors)
        or (buffer.diagnostics.warnings ~= 0 and '  ' .. buffer.diagnostics.warnings)
        or ''
    end,
    fg = function(buffer)
      return
        (buffer.diagnostics.errors ~= 0 and errors_fg)
        or (buffer.diagnostics.warnings ~= 0 and warnings_fg)
        or nil
    end,
    truncation = { priority = 1 },
  },

  close_or_unsaved = {
    text = function(buffer)
      return buffer.is_modified and '●' or ''
    end,
    fg = function(buffer)
      return buffer.is_modified and warnings_fg or nil
    end,
    delete_buffer_on_left_click = true,
    truncation = { priority = 1 },
  },
}

require('cokeline').setup({
  buffers = {
    new_buffers_position = 'next',
  },
  rendering = {
    max_buffer_width = 30,
  },
  default_hl = {
    fg = function(buffer)
      return
        buffer.is_focused
        and get_hex('Normal', 'fg')
         or get_hex('Comment', 'fg')
    end,
    bg = function(buffer)
      return buffer.is_focused and '#404040' or nil
    end
  },
  sidebar = {
    filetype = 'neo-tree',
    components = {
      components.separator,
      components.space,
      { text = 'neo-tree' },
    }
  },
  components = {
    components.separator,
    components.space,
    components.number,
    components.space,
    components.devicon,
    components.space,
    components.unique_prefix,
    components.filename,
    components.diagnostics,
    components.space,
    components.close_or_unsaved,
    components.space,
  },
})
EOF
'''

[[plugins]]
repo = 'stevearc/stickybuf.nvim'
hook_add = '''
lua << EOF
require("stickybuf").setup({
  filetype = {
    ['neo-tree'] = 'filetype',
  },
})
EOF
'''
